

\chapter{Introducción}

\section{Objetivos del trabajo}

El objetivo de este trabajo es desarrollar un escenario didáctico que permita a los analistas de ciberseguridad mejorar sus capacidades de detección e investigación mediante la comprensión del proceso completo de creación de un ciberataque. El resultado final del proyecto será un conjunto de artefactos forenses de los sistemas infectados, que servirá como base para ejercicios de análisis forense (blue team).

Para generar dicho recurso, el núcleo del trabajo se centrará en la concepción, diseño y desarrollo de un ciberataque realista, su ejecución controlada en un sistema víctima y la documentación íntegra del proceso ofensivo llevado a cabo. De este modo, quien reciba los artefactos forenses podrá analizar la infección desde el punto de vista del analista forense, pero también interpretar las acciones del atacante, entendiendo mejor el cómo y el porqué de cada artefacto encontrado.

En definitiva, este trabajo busca aproximar al analista a la mentalidad del atacante, con el fin de reforzar sus habilidades de detección, interpretación y respuesta ante amenazas reales.

\section{Adversary Emulation}

Este trabajo se sitúa dentro del ámbito de la \textit{simulación de adversarios} (\textit{Adversary Simulation}), una metodología que permite evaluar de forma controlada tanto la eficacia de los sistemas de defensa como las capacidades del personal ante incidentes de seguridad. 

Aunque esta técnica puede aplicarse para probar sistemas, en este caso concreto el enfoque principal es la formación del personal. Se utiliza un escenario de ataque realista para que los analistas practiquen la detección, el análisis y la interpretación de un incidente completo, mejorando sus habilidades y comprensión del comportamiento de un atacante.

\section{Enunciado}

Este recurso está diseñado para servir como material práctico de entrenamiento para analistas de seguridad. A continuación se presenta una breve descripción de la infraestructura de la organización víctima, junto con un enlace al conjunto completo de artefactos recopilados durante el incidente.

El objetivo del analista es reconstruir la historia completa del ataque a partir de dichos artefactos. Para facilitar este proceso, el trabajo se organiza en dos capítulos principales: en el capítulo \textit{El Incidente} \ref{chap:incidente} se detalla de forma minuciosa cada acción realizada por el atacante, sus objetivos, las técnicas MITRE ATT\&CK asociadas y los artefactos donde pueden encontrarse evidencias; por otra parte, el capítulo \textit{Red Team Notes} \ref{chap:red-team} ofrece una visión desde la perspectiva del atacante, explicando los procedimientos empleados para ejecutar el ataque.

\subsection*{Infraestructura de la víctima}

Como base del entorno corporativo se emplea \textbf{GOAD-Light}, una versión reducida del laboratorio GOAD orientada a entornos de Active Directory vulnerables. Este entorno proporciona un dominio Windows preconfigurado, servicios esenciales y múltiples debilidades que permiten simular técnicas reales de compromiso y movimiento lateral.  

Las características completas del entorno GOAD-Light están documentadas por sus autores \cite{goad-light}.

Dentro del dominio se integra una \textbf{workstation Windows 11}, actualizada y con todas las protecciones nativas habilitadas. Esta máquina actúa como punto de entrada inicial del ataque y como elemento de interacción principal del usuario víctima.

Para maximizar la visibilidad durante el análisis forense y aumentar el volumen de artefactos disponibles, se incorporan dos componentes adicionales:

\begin{itemize}
    \item \textbf{Suricata}: desplegada para la monitorización y captura del tráfico de red, permitiendo correlacionar actividad sospechosa, conexiones salientes y patrones asociados al \textit{command and control}.
    \item \textbf{Sysmon}: configurado en la workstation para generar telemetría enriquecida de eventos de Windows (creación de procesos, carga de DLLs, conexiones de red, modificaciones en el registro, entre otros), facilitando la reconstrucción temporal y contextual del ataque.
\end{itemize}

\subsection{Recopilación de evidencias}

En el siguiente enlace se encuentran todas las evidencias recopiladas del incidente:

\begin{center}
\href{https://drive.google.com/drive/folders/18eekh9kx51psuuTZ_nHl3NHEQLJb7zRV?usp=drive_link}{\textbf{Carpeta de evidencias del incidente}}
\end{center}

Cada carpeta corresponde a un equipo de la organización y lleva su nombre. Dentro de cada una se incluyen todos los artefactos adquiridos.

Los artefactos consisten en un volcado de la memoria RAM del equipo y otros elementos relevantes obtenidos durante la adquisición.

La recopilación se ha realizado con la herramienta \textbf{KAPE}, utilizando archivos \texttt{.tkape}. Estos archivos definen qué artefactos se recolectan, desde qué rutas y con qué reglas. Una explicación detallada sobre qué es un Target de KAPE puede consultarse en \cite{kape-targets}.

En este caso, se han utilizado los siguientes Targets:

\begin{itemize}
    \item \texttt{\string!SANS\_Triage} \cite{sans_triage_kape}
    \item \texttt{EventLogs} \cite{eventlogs_kape}
\end{itemize}

\subsection{Cómo utilizar este recurso}

Este recurso está pensado para servir como guía de apoyo durante el análisis del incidente y como material de referencia técnica para comprender en detalle cómo se desarrolló el ataque.

El contenido se organiza en dos bloques complementarios:

\begin{itemize}
    \item \textbf{Bloque 1: Reconstrucción del ciberataque.}  
    Presenta una visión estructurada del ataque, mapeando cada acción del adversario con las técnicas MITRE ATT\&CK aplicadas y con los artefactos del sistema víctima donde podría encontrarse evidencia relevante. Este bloque está orientado a facilitar el trabajo del analista DFIR durante el proceso de correlación y reconstrucción de los hechos.

    \item \textbf{Bloque 2: Red Team Notes.}  
    Describe el ataque desde el punto de vista del adversario, explicando el razonamiento, las decisiones técnicas y los procedimientos utilizados en cada fase. Ofrece una visión interna del flujo del ataque y del funcionamiento de cada componente ofensivo.
\end{itemize}

El documento está diseñado para que el analista pueda avanzar de forma autónoma utilizando únicamente las evidencias del caso. Si en algún momento necesita orientación sobre dónde buscar rastros de una técnica, puede consultar el Bloque~1. Si, en cambio, desea entender en profundidad por qué el atacante actuó de una determinada manera o cómo funciona una técnica concreta, puede acudir al Bloque~2, donde se detalla su implementación desde la perspectiva del red team.

\begin{center}
\fbox{
    \begin{minipage}{0.75\textwidth}
        \centering
        \textbf{Si deseas analizar el caso sin spoilers, no continúes leyendo.}
    \end{minipage}
}
\end{center}




\chapter{Marco Teórico}

\section{MITRE ATT\&CK}

MITRE ATT\&CK es el marco de referencia fundamental para describir y clasificar el comportamiento de actores maliciosos en ejercicios de \textit{Adversary Emulation}. Su estructura proporciona un vocabulario común basado en tres niveles de abstracción:

\begin{itemize}
    \item \textbf{Tácticas (el ``para qué'')}: Representan los objetivos tácticos del adversario en cada fase del ataque. Describen la meta que se pretende alcanzar, como obtener acceso inicial, elevar privilegios o exfiltrar información.

    \item \textbf{Técnicas (el ``qué'')}: Definen el método concreto que utiliza el adversario para cumplir una táctica. Representan la acción observable destinada a lograr el objetivo, como el uso de \textit{phishing}, ejecución de comandos o inyección de procesos.

    \item \textbf{Procedimientos (el ``cómo'')}: Son la implementación específica de una técnica. Detallan los pasos exactos, herramientas, parámetros y artefactos utilizados por un atacante. Un procedimiento debe ser lo suficientemente preciso como para que el \textit{Blue Team} pueda generar reglas de detección y el \textit{Red Team} pueda reproducirlo fielmente.
\end{itemize}

Este modelo estructurado permite mapear comportamientos reales, estandarizar evaluaciones y alinear las actividades defensivas y ofensivas dentro de un lenguaje común.

\section{Cyber Kill Chain (CKC)}

La \textit{Cyber Kill Chain}, desarrollada por Lockheed Martin, describe las fases operativas de un ciberataque con el objetivo de estructurar y contextualizar las acciones del adversario. No se trata de un marco rígido, sino de un modelo conceptual que divide el ataque en etapas bien definidas para facilitar su análisis, detección e interrupción. El modelo identifica las tareas que un adversario debe completar para alcanzar su objetivo final, permitiendo anticipar comportamientos y reforzar las defensas en cada fase.

Los siete pasos de la \textit{Cyber Kill Chain} mejoran la visibilidad del analista sobre el ataque y enriquecen su comprensión de las tácticas, técnicas y procedimientos (TTPs) empleados por el adversario.

\begin{enumerate}
    \item \textbf{Reconocimiento}: Investigación del objetivo y recolección de información.
    \item \textbf{Armamento}: Preparación o creación del payload y capacidades ofensivas asociadas.
    \item \textbf{Entrega}: Transmisión del payload mediante el vector seleccionado.
    \item \textbf{Explotación}: Activación del payload aprovechando una vulnerabilidad o interacción del usuario.
    \item \textbf{Instalación}: Establecimiento del implante y preparación del entorno persistente.
    \item \textbf{Mando y Control (C2)}: Creación del canal de comunicación entre el host comprometido y el adversario.
    \item \textbf{Acciones sobre Objetivos}: Ejecución de los objetivos finales, como movimiento lateral, exfiltración o impacto.
\end{enumerate}

\section{Threat Intelligence}

La Inteligencia de Amenazas es esencial para la simulación de adversarios (\textit{Adversary Simulation}), ya que transforma datos sobre actores maliciosos, campañas y vulnerabilidades en información procesable. Se nutre de análisis técnicos, alertas de organismos de ciberseguridad, investigaciones de la industria y colecciones especializadas de TTPs mantenidas por la comunidad, como la \textit{Adversary Emulation Library} \cite{mitreAEL}, desarrollada por el \textit{MITRE Center for Threat-Informed Defense}. Este recurso proporciona perfiles de adversarios basados en comportamientos observados en grupos APT, aportando una base verificable para la creación de escenarios.

Esta información, estructurada mediante MITRE ATT\&CK y contextualizada a través de la \textit{Cyber Kill Chain}, permite diseñar simulaciones realistas, evaluar defensas, identificar brechas y entrenar al personal frente a amenazas alineadas con el panorama actual.


\chapter{El Incidente}
\label{chap:incidente}

\section{Descripción del Atacante}

En este trabajo no se utiliza un adversario existente ni se replica el comportamiento de un APT conocido. En su lugar, se crea un atacante propio con el fin de construir un escenario didáctico totalmente adaptado a los objetivos del ejercicio. Esto permite ajustar, durante la elaboración del ataque, sus tácticas, técnicas y decisiones operativas para que encajen exactamente con las necesidades formativas del proyecto.

Aunque el adversario no está definido por completo al inicio, el ataque presentado sí constituye un escenario cerrado: la intrusión ya ha ocurrido y todas las evidencias están disponibles para su análisis.

\section{Descripción del Ataque (Resumen Ejecutivo)}

El escenario planteado reproduce un ataque estructurado en dos fases, diseñado para simular el comportamiento de un adversario realista. En la fase inicial, el atacante obtiene acceso al equipo víctima mediante un dispositivo físico que le permite ejecutar código de forma inmediata. Con este punto de apoyo establece una conexión remota hacia su infraestructura externa, desde la cual realiza un reconocimiento básico del sistema y prepara la siguiente fase.

En la segunda fase, el adversario despliega su componente principal, diseñado para operar de forma discreta y mantenerse en el sistema sin levantar alertas. Este componente establece persistencia, amplía la capacidad de control del atacante y se integra en procesos legítimos del sistema para dificultar su detección. A partir de este momento, el adversario puede llevar a cabo acciones más avanzadas, como analizar el entorno, escalar privilegios, desplazarse por la red o extraer información.

\section{Mapeo del Ataque a la Cyber Kill Chain y MITRE ATT\&CK}

En esta sección se presenta una referencia técnica que describe el ataque desde el punto de vista del adversario. Se detalla qué acciones llevó a cabo el atacante, cuáles eran sus objetivos en cada fase y qué técnicas MITRE ATT\&CK aplicó. Cada acción se mapea con los artefactos del sistema víctima donde podría encontrarse información relevante sobre dicha actividad, proporcionando una visión clara y útil para el análisis.

La \textit{Cyber Kill Chain} se utiliza como marco para organizar la exposición. El orden elegido es cronológico inverso —del estado final del ataque hacia sus fases iniciales—, ya que este enfoque facilita que el analista comprenda la secuencia real de los hechos: en un escenario DFIR, la investigación siempre comienza desde el impacto final y progresa hacia atrás.

El objetivo de esta sección es ofrecer una guía técnica que relacione de forma directa:
\begin{itemize}
    \item Las acciones ofensivas del atacante,
    \item Las técnicas MITRE ATT\&CK asociadas,
    \item Los artefactos del sistema donde podría hallarse evidencia de cada acción.
\end{itemize}

No se trata de una investigación completa, sino de una referencia estructurada que ayuda a entender cómo se manifiestan las técnicas del atacante en el sistema comprometido.

\subsection{Acciones sobre el objetivo}

\paragraph{Ransomware} En este punto, el atacante ya ha permanecido un periodo considerable dentro de la organización, llevando a cabo diversas actividades de post‑explotación. En la fase final de su operación ejecuta el cifrado de información crítica en el sistema comprometido.

Para una descripción detallada del procedimiento llevado a cabo por el adversario, consúltese el Capítulo~\ref{chap:red-team}, específicamente la Sección~\ref{sec:ransomware}, donde se analiza el proceso completo con mayor profundidad.
\begin{leftbar}
    \begin{description}
        \item[Táctica:] Impact (TA0040).
        \item[Técnicas:] Data Encrypted for Impact (T1486).
        \item[Procedimiento:] Se desplegó un \textit{.NET assembly} dentro del proceso donde residía el implante. Este componente cifró el fichero \texttt{documento\_importante.txt} utilizando criptografía simétrica. La clave simétrica fue posteriormente cifrada con una clave pública de un esquema asimétrico controlado por el atacante. Finalmente, se dejó una nota de rescate con un correo electrónico de contacto.
    \end{description}
\end{leftbar}

\textbf{Artefactos relevantes}
\begin{itemize}
    \item ...
\end{itemize}

\subsection{Mando y Control (C2)}

\paragraph{Sliver C2} En este punto, el atacante ya ha superado las fases de explotación e instalación y dispone de un mecanismo persistente que le permite interactuar de forma continua con el sistema víctima mediante un implante de \textit{Sliver}.

Para una descripción detallada del proceso mediante el cual el implante de Sliver se carga en memoria en cada ejecución, evitando la detección por parte del EDR, consúltese el Capítulo~\ref{chap:red-team}, Sección~\ref{sec:reflective}. 

Asimismo, para obtener información sobre la infraestructura de servidores utilizada por el atacante, véase la Sección~\ref{sec:infraestructura}.

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Defense Evasion (TA0005).
        \item[Técnica:] Reflective Code Loading (T1620).
        \item[Procedimiento:] La DLL maliciosa carga el implante de Sliver directamente en memoria mediante carga reflexiva, evitando el uso de APIs convencionales de carga de librerías y reduciendo la presencia de artefactos en disco. Este método permite ejecutar el payload de forma sigilosa dentro del proceso legítimo comprometido.
    \end{description}
\end{leftbar}

\textbf{Artefactos relevantes}
\begin{itemize}
    \item ...
\end{itemize}

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Command and Control (TA0011).
        \item[Técnicas:]
        \begin{itemize}
            \item Application Layer Protocol: Web Protocols (T1071.001).
            \item Encrypted Channel (T1573).
        \end{itemize}
        \item[Procedimiento:] El implante residente en memoria mantiene un canal de comunicación continuo (\textit{beaconing}) con la infraestructura de mando y control (C2). Para evitar su detección, todo el intercambio de información se realiza a través de tráfico HTTPS (T1071.001), encapsulando las órdenes y las respuestas dentro de peticiones y respuestas web aparentemente legítimas. Además, el canal está protegido mediante cifrado (T1573), lo que dificulta la inspección del contenido y permite al atacante operar sin generar patrones de tráfico anómalos.
    \end{description}
\end{leftbar}

\textbf{Artefactos relevantes}
\begin{itemize}
    \item ...
\end{itemize}

\subsection{Instalación}

\paragraph{Stage 2} En esta fase, el atacante ya ha superado la etapa de explotación inicial y ha logrado ejecutar código en el sistema víctima, obteniendo una \textit{reverse shell}. A partir de este acceso, procede a preparar el \textit{stage 2} del ataque y a desplegar su \textit{payload} final, cuyo objetivo es establecer un mecanismo de acceso persistente al sistema comprometido.

Para lograrlo, el adversario emplea una combinación de técnicas basadas en \textit{DLL Hijacking}, \textit{Side Loading} y \textit{DLL Proxying}. Un análisis detallado de este procedimiento puede consultarse en el Capítulo~\ref{chap:red-team}, Sección~\ref{sec:dll-hijacking}.

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Defense Evasion (TA0005).
        \item[Técnica:] Modify Registry or File Permissions: File and Directory Permissions Modification (T1222).
        \item[Procedimiento:] El atacante traslada un ejecutable legítimo a un directorio donde tiene permisos de escritura. Esto le permite manipular su entorno de carga de librerías y preparar el escenario para el secuestro de DLL.
    \end{description}
\end{leftbar}

\textbf{Artefactos relevantes}
\begin{itemize}
    \item ...
\end{itemize}

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Execution (TA0002).
        \item[Técnica:] Ingress Tool Transfer (T1105).
        \item[Procedimiento:] El atacante descarga una DLL maliciosa (implante de Sliver) dentro del mismo directorio del binario legítimo. La DLL recibe el nombre exacto de la librería que la aplicación espera cargar, preparando el entorno para alterar su flujo de ejecución.
    \end{description}
\end{leftbar}

\textbf{Artefactos relevantes}
\begin{itemize}
    \item ...
\end{itemize}

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Defense Evasion / Privilege Escalation (TA0005 / TA0004).
        \item[Técnica:] Hijack Execution Flow: DLL Search Order Hijacking (T1574.001).
        \item[Procedimiento:] El atacante renombra la DLL legítima y coloca la DLL maliciosa con el nombre original. Debido al orden de búsqueda de DLLs en Windows, la aplicación carga primero la DLL maliciosa, permitiendo al atacante ejecutar su código implantado.
    \end{description}
\end{leftbar}

\textbf{Artefactos relevantes}
\begin{itemize}
    \item ...
\end{itemize}

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Defense Evasion (TA0005).
        \item[Técnica:] Masquerading: Match Legitimate Name or Location (T1036.005).
        \item[Procedimiento:] La DLL maliciosa exporta las mismas funciones que la DLL legítima y actúa como proxy, reenviando llamadas al componente renombrado. Esto reduce los indicadores de anomalía y asegura que el comportamiento externo de la aplicación permanezca funcional mientras el implante ejecuta sus acciones encubiertas.
    \end{description}
\end{leftbar}

\textbf{Artefactos relevantes}
\begin{itemize}
    \item ...
\end{itemize}

\paragraph{Persistencia} El atacante establece un mecanismo de persistencia mediante la creación de una tarea programada, garantizando así que su \textit{payload} se ejecute automáticamente tras cada reinicio del sistema y mantenga el acceso al entorno comprometido.

Para una descripción detallada del procedimiento, consúltese el Capítulo~\ref{chap:red-team}, Sección~\ref{sec:persistencia}.

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Persistence (TA0003).
        \item[Técnica:] Scheduled Task/Job (T1053).
        \item[Procedimiento:] El atacante crea una tarea programada para ejecutar el binario legítimo modificado en cada reinicio del sistema. De esta forma garantiza que la DLL maliciosa se cargue de nuevo y el implante de Sliver recupere la persistencia tras reinicios.
    \end{description}
\end{leftbar}

\textbf{Artefactos relevantes}
\begin{itemize}
    \item ...
\end{itemize}

\subsection{Explotación}

\paragraph{Stage 1} En este punto, el atacante obtiene la primera ejecución de código en el sistema víctima y despliega el \textit{payload} inicial que le permite establecer una reverseshell con el equipo comprometido.

Para una descripción detallada del desarrollo y funcionamiento de este \textit{payload}, véase el Capítulo~\ref{chap:red-team}, Sección~\ref{sec:shellcode}.

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Execution (TA0002).
        \item[Técnica:] Command and Scripting Interpreter: PowerShell (T1059.001).
        \item[Procedimiento:] El atacante ejecuta un script de PowerShell automatizado para descargar y lanzar un payload malicioso, aprovechando las capacidades nativas del sistema para evadir controles.
    \end{description}
\end{leftbar}

\textbf{Artefactos relevantes}
\begin{itemize}
    \item ...
\end{itemize}

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Resource Development / Execution (TA0002, TA0042).
        \item[Técnica:] Ingress Tool Transfer (T1105).
        \item[Procedimiento:] El atacante transfiere un binario al sistema comprometido utilizando canales de comunicación permitidos.
    \end{description}
\end{leftbar}

\textbf{Artefactos relevantes}
\begin{itemize}
    \item ...
\end{itemize}

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Execution (TA0002).
        \item[Técnica:] User Execution: Malicious File (T1204.002).
        \item[Procedimiento:] El atacante induce al sistema a ejecutar un archivo aparentemente benigno (descargado desde PowerShell), que en realidad contiene código malicioso diseñado para establecer el acceso inicial.
    \end{description}
\end{leftbar}

\textbf{Artefactos relevantes}
\begin{itemize}
    \item ...
\end{itemize}

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Execution (TA0002) / Command and Control (TA0011).
        \item[Técnica:] Remote Services / Reverse Shell (T1021).
        \item[Procedimiento:] El atacante ejecuta un payload que establece una reverse shell hacia un servidor remoto, permitiendo el control interactivo del sistema comprometido desde la infraestructura del atacante.
    \end{description}
\end{leftbar}

\textbf{Artefactos relevantes}
\begin{itemize}
    \item ...
\end{itemize}

\subsection{Entrega}

\paragraph{BadUSB} En este punto, el atacante interactúa por primera vez con la organización víctima, marcando el inicio del incidente de seguridad. El objetivo de esta acción es introducir el primer \textit{payload} dentro del entorno de la víctima mediante un dispositivo \textit{BadUSB}.

Para un análisis detallado de las decisiones tomadas durante esta fase, véase el Capítulo~\ref{chap:red-team}, Sección~\ref{sec:bad-usb}.

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Initial Access (TA0001).
        \item[Técnica:] Replication Through Removable Media (T1091).
        \item[Procedimiento:] Se emplea un dispositivo \textit{BadUSB} que, al ser conectado, emula un dispositivo de interfaz humana (HID) para inyectar y ejecutar un script de PowerShell.
    \end{description}
\end{leftbar}

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Execution (TA0002).
        \item[Técnica:] Input Injection (T1674).
        \item[Procedimiento:] El atacante emplea un dispositivo USB malicioso capaz de emular pulsaciones de teclado. Mediante esta inyección de entrada, se lanza de forma automatizada una instancia de PowerShell que permite iniciar la cadena de ejecución maliciosa.
    \end{description}
\end{leftbar}

\textbf{Artefactos relevantes.}  
\begin{itemize}
    \item ... 
\end{itemize}

\subsection{Armamento}

En esta fase, el atacante prepara los \textit{payloads}, herramientas y la infraestructura que utilizará durante el ataque. Al igual que ocurre con la fase de reconocimiento, esta etapa se sitúa más cerca del análisis preventivo que del análisis forense de un incidente.

Las acciones llevadas a cabo por el atacante en esta fase se describen en el capítulo \textit{Red Team Notes} (ver Sección~\ref{chap:red-team}), donde se detallan, desde la perspectiva ofensiva, el desarrollo de los \textit{payloads}, las decisiones técnicas tomadas y la infraestructura empleada para ejecutar el ataque.

Desde el punto de vista del analista, esta fase puede apoyarse en servicios externos que realizan escaneos continuos de Internet en busca de infraestructuras maliciosas, como servidores de \textit{Cobalt Strike} u otros \textit{C2} con configuraciones mínimas o pobre \textit{fingerprinting}. Estos servicios permiten a la organización detectar tempranamente posibles activos maliciosos relacionados con campañas activas y, en caso necesario, aplicar medidas preventivas como el bloqueo automático de conexiones hacia o desde dichas infraestructuras.

\subsection{Reconocimiento}

En esta fase, el atacante intenta recopilar información relevante sobre la organización, sus sistemas y posibles vectores de entrada. Desde el punto de vista del analista, estas actividades suelen considerarse parte de un análisis preventivo más que de un análisis de incidente propiamente dicho.

Dentro de esta categoría se incluyen tareas como el monitoreo de actividades de reconocimiento dirigidas a los endpoints expuestos de la organización, la revisión de bases de datos comercializadas por ciberdelincuentes que contengan información relacionada con la empresa y, en general, la supervisión de cualquier actividad externa que pueda indicar la recopilación de información previa a un ataque.
 

\chapter{Red Team Notes}

\label{chap:red-team}

En esta sección se presentan todos los detalles relacionados con el desarrollo técnico del ataque, incluyendo la justificación de las decisiones adoptadas y las referencias a los repositorios necesarios para comprender y reproducir las técnicas empleadas.

\section{Acceso Inicial: Justificación del Uso de BadUSB}
\label{sec:bad-usb}

El vector de \textit{Initial Access} seleccionado para este proyecto se basa en el uso de un dispositivo \textit{BadUSB}. Aunque no se trata de un método habitual en operaciones reales —debido a la necesidad de acceso físico, la existencia de controles como el bloqueo de puertos USB o la restricción de combinaciones como \texttt{Win + R}— su utilización resulta especialmente adecuada en un contexto didáctico.

La elección de BadUSB responde a su capacidad para ofrecer un escenario de ataque claro, reproducible y fácilmente comprensible. Permite demostrar de forma directa cómo una simple emulación de teclado puede derivar en la ejecución de código arbitrario en un sistema protegido, mostrando así el impacto que puede tener un fallo en los controles físicos o en las políticas de endurecimiento del puesto de trabajo.

Desde una perspectiva de ciberseguridad, este vector no difiere conceptualmente de otros métodos de acceso inicial ampliamente empleados por actores maliciosos. Tanto la explotación de vulnerabilidades (que suele culminar en la ejecución de un \textit{payload} en memoria) como las campañas de \textit{phishing} que despliegan instaladores maliciosos (\texttt{.msi}, \texttt{.exe}) o capturan credenciales válidas, comparten la misma finalidad: obtener la primera ejecución de código en el sistema de la víctima.

Para este ejercicio se empleó un payload BadUSB de desarrollo propio, adaptado al escenario del laboratorio \cite{badusb-payload}.

\subsection{Bypass de AMSI}

Cuando el acceso inicial se realiza mediante un dispositivo BadUSB, la ejecución del código suele producirse a través de PowerShell. Esto implica que el primer mecanismo defensivo que debe evadirse habitualmente es AMSI (Antimalware Scan Interface), ya que intercepta y analiza el contenido antes de que PowerShell lo interprete.

Uno de los bypasses más utilizados es la técnica conocida como \textit{AMSI Bypass – Memory Patching}. Durante la ejecución de código, PowerShell —o cualquier motor de scripting— invoca la función \texttt{AmsiScanBuffer()} presente en \texttt{amsi.dll}. Mediante la modificación en tiempo de ejecución de los bytes asociados al valor de retorno de esta función, es posible forzar que devuelva siempre un resultado “limpio” (por ejemplo, \texttt{0x80070057}, correspondiente a \texttt{E\_INVALIDARG}). En muchas versiones de Windows, AMSI interpreta este estado como un fallo no malicioso y permite la ejecución del contenido sin aplicar medidas de bloqueo. \textit{AMSI Bypass – Memory Patching: \cite{amsi-bypass-patching}}

En determinados escenarios, AMSI puede detectar intentos de manipulación directa de \texttt{AmsiScanBuffer()} y finalizar el proceso de manera inmediata, lo que limita la eficacia del método anterior. Para abordar esta situación se emplea una técnica alternativa ampliamente documentada.

El segundo método utilizado fue el \textit{AMSI Bypass – Memory Patching via Reflection}. Durante la inicialización de PowerShell, la clase privada \\ \texttt{System.Management.Automation.AmsiUtils} crea una variable estática denominada \texttt{amsiInitFailed}. Si este valor se establece en \texttt{true}, AMSI considera que su inicialización ha fallado y desactiva de forma global todos los análisis para el resto de la sesión, independientemente de que \texttt{amsi.dll} continúe cargada y operativa. Este enfoque resulta especialmente útil en entornos donde el parcheo directo del buffer es detectado y bloqueado. \textit{AMSI Bypass - Memory Patching via Reflection: \cite{amsi-bypass-reflection}}


\section{Programar shellcodes}
\label{sec:shellcode}

Un shellcode es una secuencia de instrucciones ensambladas en formato position-independent, capaz de ejecutarse en cualquier ubicación de memoria sin asumir un punto de entrada fijo. Esto permite que, independientemente de dónde sea cargado el bloque de código, su ejecución produzca un comportamiento controlado y determinista, característica esencial en escenarios de explotación y ejecución arbitraria.

\subsection{Position-Independent Code (PIC)}

Una característica fundamental del \textit{shellcode} es que debe estar implementado como \textit{Position-Independent Code} (PIC). Esto implica que el código puede ejecutarse desde cualquier dirección de memoria sin asumir un \textit{entry point} fijo. A diferencia de los programas compilados tradicionalmente —por ejemplo, un binario en C— que comienzan su ejecución en una dirección conocida y pueden referenciar offsets internos predecibles, un \textit{shellcode} se ejecuta desde ubicaciones arbitrarias, desconocidas para sí mismo.

Para funcionar correctamente en este entorno dinámico, el \textit{shellcode} debe ser capaz de determinar en tiempo de ejecución su posición en memoria. En arquitecturas como x86, una técnica clásica para lograrlo es el patrón \texttt{call-pop}, que permite recuperar el valor del contador de programa (\texttt{EIP}):

\begin{verbatim}
_start:
    call geteip

geteip:
    pop edx
    lea edx, [edx - 5]
\end{verbatim}

La instrucción \texttt{call} empuja en la pila la dirección de retorno, que corresponde a la siguiente instrucción ejecutable. Al hacer un \texttt{pop} sobre ese valor, el \textit{shellcode} recupera la dirección efectiva donde se encuentra en memoria. Restando el tamaño de la instrucción previa, se obtiene así el punto de inicio del propio bloque de código.  

Esta técnica permite que el \textit{shellcode} utilice rutas relativas para acceder a datos incrustados, cadenas, estructuras o código adicional, manteniendo su independencia respecto a la dirección donde haya sido inyectado.


\subsection{Runtime Linking}

Una vez resuelto el problema del \textit{Position Independent Code} (PIC), el siguiente desafío fundamental en el desarrollo de shellcode es cómo invocar código de librerías dinámicas del sistema operativo. Cualquier operación relevante en Windows —como gestionar archivos, crear procesos o interactuar con memoria— requiere acceder a las \textit{system calls} expuestas a través de módulos como \texttt{kernel32.dll}. Sin embargo, en un shellcode no disponemos del trabajo que normalmente realizan el \textit{linker} en tiempo de compilación y el \textit{loader} en tiempo de carga, por lo que debemos reproducir este proceso manualmente durante la ejecución.

El objetivo principal consiste en localizar módulos cargados en el proceso y resolver las direcciones de sus funciones exportadas en tiempo de ejecución. Para ello recurrimos al \textit{Process Environment Block} (PEB), cuya dirección es mantenida por la CPU en registros dedicados (\texttt{FS:[0x30]} en x86 y \texttt{GS:[0x60]} en x64). Desde el PEB es posible iterar sus estructuras internas, en particular la lista doblemente enlazada \textit{InMemoryOrderModuleList}, que contiene información sobre todos los módulos cargados, incluyendo sus \textit{base addresses}.

Una vez obtenida la base de un módulo concreto, el siguiente paso es analizar sus encabezados PE hasta localizar la \textit{Export Table}. Esta tabla contiene los nombres de las funciones exportadas, sus \textit{ordinals} y, lo más importante, los \textit{Relative Virtual Addresses} (RVAs) que permiten calcular la dirección real de cada función mediante:

\[
\text{func\_addr} = \text{module\_base} + \text{RVA}
\]

Iterando esta tabla hasta encontrar la función deseada, el shellcode puede reconstruir la dirección exacta y, a partir de ese momento, invocar la API igual que lo haría un binario convencional.

Este mecanismo resuelve completamente la problemática del \textit{runtime linking} dentro de un entorno sin información previa como es el shellcode. Para este proyecto se han utilizado implementaciones propias en ensamblador tanto para la obtención del \textit{module base address} a través del PEB, como para la resolución dinámica de funciones exportadas. Dichas implementaciones pueden consultarse en los siguientes repositorios:

\begin{itemize}
    \item Implementación de \texttt{GetModuleHandle}-like:
    \begin{itemize}
        \item x64: \cite{x64_get_module}
        \item x86: \cite{x86_get_module}
    \end{itemize}
    \item Implementación de \texttt{GetProcAddress}-like:
    \begin{itemize}
        \item x64: \cite{x64_get_proc}
        \item x86: \cite{x86_get_proc}
    \end{itemize}
\end{itemize}

\subsubsection{Hashing de nombres de funciones}

Como medida de evasión y anti-análisis, es conveniente evitar incluir cadenas de texto en claro dentro del shellcode. Si los nombres de las funciones o módulos aparecen directamente en el binario, un analista puede identificarlos de manera inmediata aplicando herramientas básicas de extracción de cadenas. Para mitigar esto, una técnica habitual consiste en emplear algoritmos de \textit{hashing} para representar los nombres de las funciones que queremos resolver en tiempo de ejecución.

En este proyecto se ha implementado un sistema de hashing sencillo basado en rotaciones y operaciones XOR. Con este mecanismo, el shellcode almacena únicamente los valores hash, lo que dificulta la identificación directa de las APIs utilizadas. Durante la ejecución, las funciones exportadas del módulo correspondiente se recorren una a una, calculando su hash y comparándolo con el valor objetivo.

Las implementaciones en ensamblador utilizadas son las siguientes:

\begin{itemize}
    \item Hashing x64: \cite{x64_hash}
    \item Hashing x86: \cite{x86_hash}
\end{itemize}

\subsection{ABI en x86 y x64}

Finalmente, al trabajar con shellcode es imprescindible respetar las reglas de la \textit{Application Binary Interface} (ABI), especialmente en entornos x64. En esta arquitectura, la pila debe mantenerse alineada a 16 bytes en el momento de realizar una llamada a una función (\texttt{RSP mod 16 = 0}). Además, la convención de llamadas de Windows x64 exige reservar un \textit{shadow space} de 32 bytes antes de invocar cualquier función de una DLL del sistema; si estas condiciones no se cumplen, las llamadas pueden fallar de forma silenciosa o provocar un comportamiento indefinido.

También es necesario considerar la convención de llamadas utilizada para interactuar con las APIs del sistema. En x86, los argumentos se pasan por pila siguiendo un orden \textit{right-to-left}. En x64, los primeros cuatro parámetros se pasan mediante registros (\texttt{RCX}, \texttt{RDX}, \texttt{R8} y \texttt{R9}), mientras que el resto se colocan en la pila respetando la alineación mencionada. Asimismo, la gestión de \textit{stack frames}, la preservación de registros no volátiles y otras tareas que habitualmente realiza el compilador deben ser manejadas explícitamente dentro del shellcode.

Cumplir estrictamente estas normas resulta esencial para garantizar que las funciones del sistema operativo se ejecuten correctamente y que el shellcode mantenga un comportamiento estable y predecible.

\subsection{Payloads finales}

Una vez establecidos los tres pilares fundamentales para el desarrollo de shellcode —\textit{Position Independent Code} (PIC), \textit{runtime linking} y respeto de la ABI— es posible construir payloads completamente personalizados desde cero.

Como recomendación práctica, resulta útil desarrollar primero el programa equivalente en C y compilarlo sin optimizaciones. Esto permite tener una referencia clara de cómo debería verse el comportamiento final y observar directamente cómo el compilador gestiona aspectos como las llamadas a funciones, las variables locales o el uso del stack.

De forma adicional, en algunas circunstancias puede ser útil cargar un binario compilado en C en una herramienta de análisis estático como IDA, para comprobar el tamaño que el compilador reserva para ciertas variables o estructuras. Esto es especialmente práctico cuando ciertos valores no son triviales de deducir únicamente a partir de la documentación.

A continuación se muestran ejemplos de payloads desarrollados para este proyecto:

\paragraph{MessageBox payload}  
Un payload sencillo cuyo objetivo es mostrar un \textit{message box}. Se ha utilizado para validar las rutinas de inyección de código y comprobar la correcta resolución de funciones mediante \textit{runtime linking}.

\begin{itemize}
    \item x64: \cite{github-messagebox-x64}
    \item x86: \cite{github-messagebox-x86}
\end{itemize}

\paragraph{Reverse Shell payload}
Este es el \textbf{payload utilizado en la versión final del ataque} descrito en este trabajo. Se trata de la reverse shell empleada durante toda la ejecución práctica del ejercicio Red Team.

Por motivos didácticos, el shellcode de la reverse shell se ha incluido dentro de un fichero PE mínimo para que quede rastro en disco y su análisis resulte más sencillo posteriormente.
Para generar este PE se ha utilizado la herramienta \texttt{sclauncher} \cite{sclauncher}, que crea únicamente las cabeceras básicas del ejecutable, define una sección \texttt{.text} y coloca en ella el bloque de shellcode. De este modo, el loader de Windows lo mapea correctamente y transfiere la ejecución a la shellcode sin necesidad de estructuras adicionales.

\begin{itemize}
\item \textbf{Reverse shell x86 (payload final utilizado en el ataque):} \cite{github-reverseshell-x86}
\end{itemize}

\section{Inyección de código}

La inyección de código consiste en conseguir que un proceso ejecute instrucciones distintas a las previstas originalmente. Existen múltiples técnicas para lograrlo, pero todas se basan en un principio común: modificar el flujo de ejecución o incorporar código arbitrario dentro del espacio de memoria de un proceso legítimo.

Los métodos clásicos incluyen la reserva de memoria en el proceso objetivo para copiar y ejecutar shellcode, así como la carga forzada de librerías que el binario no tenía previstas. Esta última categoría da lugar a un conjunto amplio de técnicas orientadas a manipular la forma en que Windows resuelve y carga DLLs.

Dentro de estas técnicas, una de las más relevantes y estudiadas es el DLL Hijacking. 

\subsection{DLL Hijacking}

El \textit{DLL Hijacking} consiste en forzar que el \textit{loader} de Windows cargue una biblioteca dinámica controlada por el atacante, aprovechando el orden de búsqueda de DLLs o configuraciones del sistema.

\paragraph{Objetivo principal}  
Lograr que un ejecutable legítimo cargue una DLL maliciosa con el mismo nombre que una DLL esperada, pero ubicada en una ruta que el atacante controla.

\subsubsection{Orden de carga de DLLs en Windows}

El \textit{loader} resuelve las dependencias siguiendo el siguiente orden:

\begin{enumerate}
    \item Directorio desde el cual se cargó la aplicación.
    \item \texttt{C:\textbackslash Windows\textbackslash System32}
    \item \texttt{C:\textbackslash Windows\textbackslash System}
    \item \texttt{C:\textbackslash Windows}
    \item Directorio de trabajo actual (CWD).
    \item Directorios definidos en la variable de entorno \texttt{PATH} del sistema.
    \item Directorios definidos en la variable de entorno \texttt{PATH} del usuario.
\end{enumerate}

\subsubsection{KnownDLLs — Restricción crítica}

Las DLL listadas en:

\begin{verbatim}
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs
\end{verbatim}

solo pueden cargarse desde \texttt{System32}, lo que imposibilita su secuestro mediante \textit{DLL Hijacking} tradicional.

\section{Weaponización de DLL Hijacking}
\label{sec:dll-hijacking}

Para transformar este mecanismo en una técnica ofensiva se emplean tres enfoques complementarios: \textit{Side Loading}, \textit{DLL Proxying} y \textit{Reflective Loading}.

En el ataque desarrollado en este trabajo se explota la aplicación legítima \textit{Calibre} y, en concreto, su librería \texttt{calibre-launcher.dll}. La vulnerabilidad asociada a esta DLL está documentada en la plataforma \textit{HijackLibs} \cite{hijacklibs-calibre-launcher}, que mantiene un catálogo actualizado de DLLs susceptibles de ser secuestradas.

El objetivo es conseguir que un ejecutable legítimo, ya presente en el sistema, cargue una DLL bajo control del atacante. En este escenario, la DLL maliciosa actúa como stage 2 del ataque. Su cometido es establecer una conexión con el C2 y descargar la carga final: una DLL que contiene un implante de Sliver. Esta DLL descargada no se escribe en disco en ningún momento; la propia DLL maliciosa la carga directamente en memoria mediante reflective loading y transfiere la ejecución al implante. De este modo, un proceso legítimo termina ejecutando código malicioso sin dejar artefactos en el sistema de archivos.

De este modo, se consigue que un proceso legítimo —en este caso, \textit{Calibre}— ejecute dentro de su propio espacio de direcciones un \textit{implant} de \textit{Sliver}, manteniendo la operación completamente \textit{fileless}.

% -----------------------------------------------------------
\subsection{Side Loading}

El primer objetivo es conseguir que un ejecutable legítimo cargue nuestra DLL maliciosa. La técnica de \textit{Side Loading} se basa en colocar una DLL bajo control del atacante en el mismo directorio que el ejecutable objetivo, utilizando exactamente el mismo nombre que la DLL legítima que el programa espera cargar. Para ello, es necesario identificar previamente aplicaciones vulnerables a este tipo de \textit{DLL Hijacking}.

Una limitación habitual es que los directorios donde residen los binarios legítimos no permiten la escritura por parte de usuarios sin privilegios elevados, lo que impide introducir la DLL maliciosa directamente. No obstante, estos directorios sí permiten lectura, de modo que el atacante puede copiar el ejecutable legítimo a una ubicación donde sí disponga de permisos de escritura y, posteriormente, insertar allí la DLL manipulada.

Una vez trasladado el ejecutable a un directorio controlado, basta con colocar la DLL maliciosa con el mismo nombre que la DLL legítima requerida por el programa. De este modo, al ejecutarse, el binario cargará la versión maliciosa en lugar de la original.

Por ejemplo, es posible copiar los archivos de la aplicación a un directorio menos restrictivo mediante:

\begin{verbatim}
robocopy "C:\Program Files\Calibre2" ^
         "%LOCALAPPDATA%\Microsoft\WindowsApps" ^
         /E /COPY:DAT /R:3 /W:5
\end{verbatim}


% -----------------------------------------------------------
\subsection{DLL Proxying}

Con la técnica de \textit{Side Loading} hemos logrado que un ejecutable legítimo cargue una DLL maliciosa. Sin embargo, esto introduce un nuevo problema: al sustituir la DLL original, el programa deja de disponer de las funciones que necesita para funcionar correctamente. Si la DLL maliciosa no reproduce esas exportaciones, la aplicación fallará o directamente no arrancará.

Para resolver este problema se utiliza \textit{DLL Proxying}. Esta técnica consiste en compilar una DLL maliciosa que:

\begin{itemize}
\item Ejecuta las operaciones ofensivas necesarias (en nuestro caso, cargar en memoria el implante final).
\item Mantiene toda la funcionalidad original de la DLL legítima, reenviando sus exportaciones reales.
\end{itemize}

\subsubsection*{Ficheros \texttt{.def}}

Para que una DLL maliciosa actúe como sustituta de otra es necesario replicar exactamente sus exportaciones. Esto se consigue mediante un fichero \texttt{.def} (Module Definition File), que permite definir explícitamente qué funciones expone la DLL y, opcionalmente, redirigir cada una a otra DLL.

La estructura básica de un fichero \texttt{.def} es:

\begin{verbatim}
EXPORTS
FuncB = real-old.FuncB @2
FuncC = real-old.FuncC @3
\end{verbatim}

Cada línea indica:

\begin{itemize}
\item el nombre que exporta la DLL maliciosa,
\item la función real a la que se redirige,
\item y el ordinal asociado.
\end{itemize}

El ordinal debe conservarse porque algunos programas importan funciones por número en lugar de por nombre.

Durante el proyecto se utilizó un script en Python para generar automáticamente estos ficheros \texttt{.def}. El script está disponible en \cite{exports_py}.
Asimismo, puede encontrarse una demostración completa de \textit{Side Loading} + \textit{DLL Proxying} en \cite{dll_proxy_demo}.

En esa prueba de concepto se crea un ejecutable que importa tres funciones (\texttt{FuncA}, \texttt{FuncB}, \texttt{FuncC}) y una DLL legítima que las implementa. La DLL maliciosa se compila de forma que:

\begin{itemize}
\item exporta su propia versión de \texttt{FuncA} (donde podría incluirse cualquier lógica ofensiva),
\item redirige \texttt{FuncB} y \texttt{FuncC} a la DLL real mediante el fichero \texttt{proxy.def}.
\end{itemize}

Una compilación típica sería:

\begin{verbatim}
x86_64-w64-mingw32-gcc -shared -o bin/malicious.dll
dll-malicious.c proxy.def -s
\end{verbatim}

Para finalizar la demostración, basta con renombrar \texttt{malicious.dll} a \texttt{dll-real.dll} y colocarlo junto al ejecutable vulnerable: en ese momento, \textit{Side Loading} y \textit{DLL Proxying} quedan operativos.

El resultado es similar a un \textit{man-in-the-middle} dentro del propio mecanismo de carga de DLLs: el programa cree estar usando la DLL legítima, pero en realidad está ejecutando código controlado por el atacante mientras conserva su funcionalidad original.
% -----------------------------------------------------------
\subsection{Reflective Loading}

Una vez logramos que un proceso legítimo cargue una DLL maliciosa sin alterar su flujo normal, el siguiente paso es introducir la carga ofensiva real. En este escenario, el objetivo es cargar una DLL directamente en el espacio de direcciones del proceso, sin que exista físicamente en disco.

Windows impone una limitación importante: las DLL solo pueden cargarse mediante las APIs estándar (\texttt{LoadLibrary} y derivados), las cuales requieren que el archivo exista en el sistema de ficheros. La técnica de \textit{Reflective Loading} evita esta restricción cargando la DLL íntegramente desde memoria. De este modo, es posible ejecutar código arbitrario sin generar artefactos en disco, reduciendo la exposición a firmas estáticas y detecciones basadas en \textit{file scanning}.

Como referencia, se ha desarrollado una demostración en C que implementa la carga manual de una DLL sin utilizar las funciones estándar del sistema~\cite{walkingloader}. El código puede consultarse en el repositorio mencionado.

\subsubsection*{Proceso de carga reflectiva}
\label{sec:reflective}

Para implementar \textit{Reflective Loading}, el programa debe llevar a cabo las siguientes etapas:

\begin{enumerate}
    \item \textbf{Preparar la DLL en memoria.}  
    El archivo PE de la DLL debe estar ya cargado en memoria, normalmente como un bloque continuo de bytes.

    \item \textbf{Procesar las cabeceras.}  
    Se interpretan las estructuras PE iniciales para obtener información crítica, incluyendo el tamaño total que ocupará la DLL en memoria (\texttt{IMAGE\_OPTIONAL\_HEADER64.SizeOfImage}).

    \item \textbf{Reservar memoria para la DLL.}  
    Se solicita al proceso un bloque de memoria con el tamaño indicado por \texttt{SizeOfImage}, donde se cargará la DLL reconstruida.

    \item \textbf{Copiar las cabeceras.}  
    Las cabeceras del PE se copian al nuevo bloque de memoria, ya que algunas estructuras deberán ser modificadas durante la carga.

    \item \textbf{Mapear las secciones.}  
    Utilizando \texttt{IMAGE\_FIRST\_SECTION}, se obtiene la dirección del primer \texttt{IMAGE\_SECTION\_HEADER}.  
    Para cada sección:
    \begin{itemize}
        \item Se leen los offsets y tamaños desde el PE en memoria.
        \item Se copian los datos a la ubicación adecuada dentro del bloque reservado, respetando el RVA definido en las cabeceras.
    \end{itemize}

    \item \textbf{Resolver la tabla de importaciones.}  
    La estructura \texttt{IMAGE\_IMPORT\_DESCRIPTOR} define los módulos y funciones requeridos por la DLL.  
    Para cada módulo importado:
    \begin{itemize}
        \item Se comprueba si ya está cargado en el proceso; si no, se carga.
        \item Se obtiene su \textit{base address}.
        \item Se recorren las tablas \texttt{PIMAGE\_THUNK\_DATA} para resolver cada función:
        \begin{itemize}
            \item El nombre de la función se obtiene de la estructura original.
            \item Se localiza su dirección en el módulo cargado.
            \item Se escribe esa dirección en la IAT reconstruida.
        \end{itemize}
    \end{itemize}
    Esto garantiza que, cuando la DLL cargada reflectivamente invoque funciones externas, las llamadas apunten a direcciones válidas.

    \item \textbf{(Opcional) Aplicar relocaciones.}  
    Si la DLL no se carga en su \texttt{ImageBase} preferido, deben procesarse las entradas de la tabla de relocaciones.  
    En esta explicación se omite por simplicidad, aunque sería necesario en una implementación completa.

    \item \textbf{Invocar \texttt{DllMain}.}  
    Con la DLL completamente mapeada en memoria y las dependencias resueltas, solo queda ejecutar:  
    \texttt{DllMain(baseAddress, DLL\_PROCESS\_ATTACH, NULL);}  
\end{enumerate}

En este punto, la DLL queda cargada y ejecutándose íntegramente desde memoria, sin intervención de las APIs estándar de Windows y sin necesidad de que exista como archivo en disco.

Esta sección no pretende ofrecer una explicación completamente sistemática de la técnica, sino proporcionar una visión operativa que permita comprender sus fundamentos. Para profundizar en el funcionamiento interno del proceso, se recomienda revisar en el anexo la sección dedicada a los ficheros PE, así como examinar detenidamente el código fuente del repositorio \cite{walkingloader}. En dicha implementación se emplean las estructuras oficiales definidas en \texttt{winnt.h}, por lo que resulta especialmente útil comparar estas estructuras con los offsets y campos especificados en la documentación del formato PE. Para ello, puede consultarse la infografía técnica incluida en \cite{peinfografia}, lo que facilita relacionar las estructuras utilizadas en la implementación con sus equivalentes formales dentro del estándar PE definido por Microsoft.

\section{Syscalls y evasión de EDR}

En este punto del ataque, el implante ya está completamente desplegado: se ejecuta en el sistema comprometido, mantiene comunicación estable con el C2 y está preparado para iniciar técnicas de post-explotación. Antes de avanzar, es imprescindible comprender los mecanismos modernos de detección utilizados por soluciones EDR, especialmente aquellos basados en \textit{hooking} de APIs.

Los EDR actuales instrumentan funciones críticas de \texttt{kernel32.dll}, \texttt{kernelbase.dll} y \texttt{ntdll.dll} mediante \textbf{API hooking}. De este modo, cada vez que el implante invoca funciones como \texttt{CreateProcessW}, \texttt{VirtualAllocEx}, \texttt{NtWriteVirtualMemory} o similares, el EDR intercepta la llamada, analiza los parámetros y decide si permitir, alertar o bloquear la operación.

Para minimizar la superficie de detección, los operadores utilizan diferentes grados de interacción directa con el sistema operativo. Estos niveles pueden organizarse en cuatro categorías progresivas, desde las API de mayor visibilidad hasta técnicas de evasión más avanzadas.

\subsection{Nivel 1 – Win32 API}

\begin{itemize}
\item Conjunto de funciones de alto nivel diseñadas para desarrollo estándar.
\item Ejemplos típicos: \texttt{CreateFileW}, \texttt{VirtualAllocEx}, \texttt{WriteProcessMemory}.
\item Resueltas estática o dinámicamente desde \texttt{kernel32.dll} o \texttt{kernelbase.dll}.
\item Constituyen el nivel más monitorizado: cualquier EDR comercial detecta su uso de forma prácticamente completa.
\end{itemize}

\cite{ref:win32api} – Demo de uso Win32 API.  

\subsection{Nivel 2 – Native API}

\begin{itemize}
\item Funciones de bajo nivel exportadas por \texttt{ntdll.dll}.
\item Siguen el prefijo \texttt{Nt} o \texttt{Zw}, como \texttt{NtCreateFile} o \texttt{NtAllocateVirtualMemory}.
\item Representan los \textit{wrappers} oficiales en espacio de usuario que preparan los registros y ejecutan la instrucción \texttt{syscall}.
\item Aunque ofrecen mayor control, muchos EDR siguen aplicando \textit{hooks} sobre estas funciones críticas.
\end{itemize}

\cite{ref:nativeapi} – Implementación de Native API para evitar hooks.  

\subsection{Nivel 3 – Direct Syscalls}

\begin{itemize}
\item Eliminan por completo la dependencia de \texttt{ntdll.dll}.
\item El operador carga manualmente el \textbf{System Service Number} (SSN) en \texttt{RAX} (x64) o \texttt{EAX} (x86) y ejecuta \texttt{syscall}.
\item El SSN varía entre versiones y compilaciones de Windows, lo cual requiere enumeración dinámica o bases de datos específicas por build.
\item Ejemplo habitual para \texttt{NtAllocateVirtualMemory}:
\begin{lstlisting}[language=C]
NtAllocateVirtualMemory PROC
mov r10, rcx
mov eax, 18h
syscall
ret
NtAllocateVirtualMemory ENDP
\end{lstlisting}
\item Los EDR modernos pueden detectar esta técnica comparando el origen de la instrucción \texttt{syscall} mediante ETW/ETW-TI, ya que no proviene de \texttt{ntdll.dll}.
\end{itemize}

\cite{ref:directsyscalls} – Ejemplo de Direct Syscalls en Windows.  

\subsection{Nivel 4 – Indirect Syscalls}

\begin{itemize}
\item Variante avanzada de las direct syscalls que reintroduce un retorno controlado hacia \texttt{ntdll.dll}.
\item El flujo salta a la instrucción original de \texttt{ntdll.dll} inmediatamente después de su propia \texttt{syscall}, preservando la legitimidad aparente del contexto.
\item Ejemplo simplificado:
\begin{lstlisting}[language=C]
EXTERN sysAddrNtAllocateVirtualMemory:QWORD

NtAllocateVirtualMemory PROC
mov r10, rcx
mov eax, 18h
jmp QWORD PTR [sysAddrNtAllocateVirtualMemory]
NtAllocateVirtualMemory ENDP
\end{lstlisting}
\item Desde la perspectiva del EDR (y de ETW), la instrucción \texttt{syscall} parece ejecutarse dentro de \texttt{ntdll.dll}, lo que la vuelve extremadamente difícil de detectar sin medidas basadas en telemetría avanzada o heurísticas de integridad de memoria.
\end{itemize}

\cite{ref:indirectsyscalls} – Ejemplo de Indirect Syscalls en Windows.

Librerías como HellGate, HaloGate, Freshycalls y SysWhispers3 automatizan la ejecución de direct e indirect syscalls para evadir hooks de EDR en ntdll.dll. Resuelven los SSN y direcciones en tiempo de compilación o carga, generan stubs limpios o reutilizan gadgets legítimos terminados en syscall; ret dentro de secciones no hookeadas de ntdll.dll (técnicas Hell’s Gate, Halo’s Gate y Tartarus’ Gate), permitiendo llamar syscalls sin tocar las funciones exportadas monitorizadas y sin escribir ensamblador manualmente.

Aunque en esta primera versión del ataque no se han empleado \textit{syscalls} directas ni técnicas de \textit{syscall bypass}, entender cómo funcionan los \textit{hooks} en \texttt{ntdll.dll} y las formas de evitarlos es esencial. Estas capacidades son clave para reducir la visibilidad frente a EDR y serán necesarias en futuras versiones del ataque.

\section{Persistencia}
\label{sec:persistencia}

En un entorno Windows existen múltiples métodos para establecer persistencia tras comprometer un sistema. 
Entre las técnicas más comunes destacan:

\begin{itemize}
    \item \textbf{Claves de registro} para ejecutar binarios maliciosos al inicio del sistema o sesión.
    \item \textbf{Servicios} configurados para iniciarse automáticamente.
    \item \textbf{Tareas programadas} creadas mediante \texttt{schtasks}.
    \item \textbf{Elementos del menú \textit{Start-up}} o carpetas de inicio.
    \item \textbf{DLL Hijacking}, aprovechando ejecutables que cargan librerías sin rutas absolutas; si el binario vulnerable se ejecuta al iniciar el sistema.
\end{itemize}

Aunque el ecosistema de técnicas de persistencia es amplio, en este ataque se optó por un método sencillo, 
estable y difícil de detectar a simple vista: la creación de una tarea programada que simula una actualización 
legítima del software instalado en el equipo. Para ello, se configuró una tarea diaria denominada 
\texttt{CalibreUpdater}, cuyo propósito aparente es ejecutar un componente de actualización del software 
Calibre, pero que en realidad invoca el \textit{payload} malicioso.

La tarea fue creada mediante el siguiente comando:

\begin{verbatim}
schtasks /create ^
  /tn "CalibreUpdater" ^
  /tr "%LOCALAPPDATA%\Microsoft\WindowsApps\Calibre2\calibre-debug.exe \
       -c \"import time; time.sleep(86400)\"" ^
  /sc daily ^
  /st 09:00
\end{verbatim}


Este enfoque permite que la persistencia pase desapercibida al camuflarse como una tarea rutinaria de 
mantenimiento del sistema, lo que reduce la probabilidad de detección durante una inspección superficial.
\section{Infraestructura C2}
\label{sec:infraestructura}

> falta desarrollar todas las decisiones de opsec \\

La infraestructura del atacante se despliega en \textbf{AWS} para garantizar aislamiento, escalabilidad y control de tráfico. Se compone de dos sistemas diferenciados:

\begin{itemize}
    \item \textbf{Servidor de entrega y control inicial}: utilizado como CDN improvisada y punto de conexión para la \textit{reverse shell} del \textit{stage 1}. Aloja los binarios iniciales y recibe las conexiones interactivas del atacante.
    \item \textbf{Servidor C2 del implante}: instancia separada destinada a ejecutar el servidor de \textit{Command and Control} del implante principal (Sliver). Gestiona comunicación, tareas, carga de módulos y telemetría durante el \textit{stage 2}.
\end{itemize}

\section{Post Explotacion}

\subsection{Exfiltracion}

\subsection{Ransomware}
\label{sec:ransomware}

