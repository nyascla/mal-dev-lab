

\chapter{Introducción}

\section{Adversary emulation}

La Emulación de Adversarios reproduce, de forma controlada, el comportamiento de actores maliciosos reales para evaluar la eficacia de las defensas existentes. Basándose en inteligencia de amenazas y TTPs documentados, permite replicar ataques específicos dentro del entorno de la organización, verificando de manera práctica si soluciones como EDR, SIEM o sistemas de detección de integridad los detectarían o mitigarían. Este enfoque no solo identifica brechas y configuraciones deficientes, sino que también contribuye a la mejora de los procesos de seguridad y al entrenamiento y concienciación del personal, conectando la inteligencia de amenazas con la defensa activa.

\section{Objetivos del trabajo}

El objetivo de este trabajo es desarrollar un escenario didáctico que permita a
los analistas de ciberseguridad mejorar sus capacidades de deteccion e investigación
mediante la comprensión del proceso completo de creación de un ciberataque. El
resultado final del proyecto será un conjunto de artefactos forenses de los
sistemas infectados, que servirá como base para ejercicios de análisis forense
(blue team).

Para generar dicho recurso, el núcleo del trabajo se centrará en la concepción,
diseño y desarrollo de un ciberataque realista, su ejecución controlada en un
sistema víctima y la documentación íntegra del proceso ofensivo llevado a cabo. 
De este modo, quien reciba los artefactos forenses podrá analizar la infección 
desde el punto de vista del analista forense, pero también interpretar las acciones del atacante, entendiendo mejor
el cómo y el porqué de cada artefacto encontrado.

En definitiva, este trabajo busca aproximar al analista a la mentalidad del
atacante, con el fin de reforzar sus habilidades de detección, interpretación y
respuesta ante amenazas reales.

\section{Infraestructura}

La infraestructura utilizada para el ejercicio se compone de dos entornos diferenciados: la red víctima y la infraestructura del adversario.

\subsection*{Infraestructura de la víctima}

Como base del entorno corporativo se emplea \textbf{GOAD-Light}, una versión reducida del laboratorio GOAD orientada a entornos de Active Directory vulnerables. Este entorno proporciona un dominio Windows preconfigurado, servicios esenciales y múltiples debilidades que permiten simular técnicas reales de compromiso y movimiento lateral.  

Las características completas del entorno GOAD-Light están documentadas por sus autores \cite{goad-light}.

Dentro del dominio se integra una \textbf{workstation Windows 11}, actualizada y con todas las protecciones nativas habilitadas (SmartScreen, Defender, ASR, Credential Guard, etc.). Esta máquina actúa como punto de entrada inicial del ataque y como elemento de interacción principal del usuario víctima.

\subsection*{Infraestructura del adversario}

La infraestructura del atacante se despliega en \textbf{AWS} para garantizar aislamiento, escalabilidad y control de tráfico. Se compone de dos sistemas diferenciados:

\begin{itemize}
    \item \textbf{Servidor de entrega y control inicial}: utilizado como CDN improvisada y punto de conexión para la \textit{reverse shell} del \textit{stage 1}. Aloja los binarios iniciales y recibe las conexiones interactivas del atacante.
    \item \textbf{Servidor C2 del implante}: instancia separada destinada a ejecutar el servidor de \textit{Command and Control} del implante principal (Sliver). Gestiona comunicación, tareas, carga de módulos y telemetría durante el \textit{stage 2}.
\end{itemize}


\chapter{Marco Teórico}

\section{MITRE ATT\&CK}

MITRE ATT\&CK es el marco de referencia fundamental para describir y clasificar el comportamiento de actores maliciosos en ejercicios de \textit{Adversary Emulation}. Su estructura proporciona un vocabulario común basado en tres niveles de abstracción:

\begin{itemize}
    \item \textbf{Tácticas (el ``para qué'')}: Representan los objetivos tácticos del adversario en cada fase del ataque. Describen la meta que se pretende alcanzar, como obtener acceso inicial, elevar privilegios o exfiltrar información.

    \item \textbf{Técnicas (el ``qué'')}: Definen el método concreto que utiliza el adversario para cumplir una táctica. Representan la acción observable destinada a lograr el objetivo, como el uso de \textit{phishing}, ejecución de comandos o inyección de procesos.

    \item \textbf{Procedimientos (el ``cómo'')}: Son la implementación específica de una técnica. Detallan los pasos exactos, herramientas, parámetros y artefactos utilizados por un atacante. Un procedimiento debe ser lo suficientemente preciso como para que el \textit{Blue Team} pueda generar reglas de detección y el \textit{Red Team} pueda reproducirlo fielmente.
\end{itemize}

Este modelo estructurado permite mapear comportamientos reales, estandarizar evaluaciones y alinear las actividades defensivas y ofensivas dentro de un lenguaje común.

\section{Cyber Kill Chain (CKC)}

La \textit{Cyber Kill Chain}, desarrollada por Lockheed Martin, describe las fases operativas de un ciberataque con el objetivo de estructurar y contextualizar las acciones del adversario. No se trata de un marco rígido, sino de un modelo conceptual que divide el ataque en etapas bien definidas para facilitar su análisis, detección e interrupción. El modelo identifica las tareas que un adversario debe completar para alcanzar su objetivo final, permitiendo anticipar comportamientos y reforzar las defensas en cada fase.

Los siete pasos de la \textit{Cyber Kill Chain} mejoran la visibilidad del analista sobre el ataque y enriquecen su comprensión de las tácticas, técnicas y procedimientos (TTPs) empleados por el adversario.

\begin{enumerate}
    \item \textbf{Reconocimiento}: Investigación del objetivo y recolección de información.
    \item \textbf{Armamento}: Preparación o creación del payload y capacidades ofensivas asociadas.
    \item \textbf{Entrega}: Transmisión del payload mediante el vector seleccionado.
    \item \textbf{Explotación}: Activación del payload aprovechando una vulnerabilidad o interacción del usuario.
    \item \textbf{Instalación}: Establecimiento del implante y preparación del entorno persistente.
    \item \textbf{Mando y Control (C2)}: Creación del canal de comunicación entre el host comprometido y el adversario.
    \item \textbf{Acciones sobre Objetivos}: Ejecución de los objetivos finales, como movimiento lateral, exfiltración o impacto.
\end{enumerate}

\section{Threat Intelligence}

La Inteligencia de Amenazas es esencial para la simulación de adversarios (\textit{Adversary Simulation}), ya que transforma datos sobre actores maliciosos, campañas y vulnerabilidades en información procesable. Se nutre de análisis técnicos, alertas de organismos de ciberseguridad, investigaciones de la industria y colecciones especializadas de TTPs mantenidas por la comunidad, como la \textit{Adversary Emulation Library} \cite{mitreAEL}, desarrollada por el \textit{MITRE Center for Threat-Informed Defense}. Este recurso proporciona perfiles de adversarios basados en comportamientos observados en grupos APT, aportando una base verificable para la creación de escenarios.

Esta información, estructurada mediante MITRE ATT\&CK y contextualizada a través de la \textit{Cyber Kill Chain}, permite diseñar simulaciones realistas, evaluar defensas, identificar brechas y entrenar al personal frente a amenazas alineadas con el panorama actual.


\chapter{Creación de un Adversario}

La definición de un adversario propio resulta esencial en un entorno didáctico y controlado, especialmente cuando el objetivo es diseñar escenarios de emulación adaptados a requisitos concretos. Frente a la simple reproducción de TTPs pertenecientes a un APT real, la construcción de un adversario personalizado ofrece una mayor flexibilidad, permite modular la complejidad técnica y facilita focalizar los ejercicios en las capacidades específicas que se desean analizar o entrenar. Además, posibilita incorporar técnicas actuales sin estar limitado a un perfil cerrado, integrando comportamientos representativos de múltiples actores con un enfoque puramente formativo.

\section{Descripción del Ataque (Resumen Ejecutivo)}

El escenario planteado reproduce un ataque estructurado en dos fases, diseñado para simular el comportamiento de un adversario realista. En la fase inicial, el atacante obtiene acceso al equipo víctima mediante un dispositivo físico que le permite ejecutar código de forma inmediata. Con este punto de apoyo establece una conexión remota hacia su infraestructura externa, desde la cual realiza un reconocimiento básico del sistema y prepara la siguiente fase.

En la segunda fase, el adversario despliega su componente principal, diseñado para operar de forma discreta y mantenerse en el sistema sin levantar alertas. Este componente establece persistencia, amplía la capacidad de control del atacante y se integra en procesos legítimos del sistema para dificultar su detección. A partir de este momento, el adversario puede llevar a cabo acciones más avanzadas, como analizar el entorno, escalar privilegios, desplazarse por la red o extraer información.

Este modelo de ataque permite evaluar la eficacia de las defensas técnicas, la adecuación de los procesos internos y la capacidad de respuesta del personal ante un incidente que replica patrones habituales en intrusiones modernas.

\section{Mapeo del Ataque a la CKC y MITRE ATT\&CK}

\subsection{Reconocimiento}

\textit{Consultar la actividad del Red Team en la Sección~\ref{sec:red-team-reconocimiento} y el análisis del Blue Team en la Sección~\ref{sec:blue-team-reconocimiento}.}


\subsection{Armamento}

\textit{Consultar la actividad del Red Team en la Sección~\ref{sec:red-team-armamento} y el análisis del Blue Team en la Sección~\ref{sec:blue-team-armamento}.}

\subsection{Entrega}

\textit{Consultar la actividad del Red Team en la Sección~\ref{sec:red-team-entrega} y el análisis del Blue Team en la Sección~\ref{sec:blue-team-entrega}.}

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Initial Access (TA0001).
        \item[Técnica:] Replication Through Removable Media (T1091).
        \item[Procedimiento:] Se emplea un dispositivo \textit{BadUSB} que, al ser conectado, emula un dispositivo de interfaz humana (HID) para inyectar y ejecutar un script de PowerShell.
    \end{description}
\end{leftbar}

\subsection{Explotación}

\textit{Consultar la actividad del Red Team en la Sección~\ref{sec:red-team-explotacion} y el análisis del Blue Team en la Sección~\ref{sec:blue-team-explotacion}.}

\subsubsection{Stage 1}

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Execution (TA0002).
        \item[Técnica:] Input Injection (T1674).
        \item[Procedimiento:] El atacante emplea un dispositivo USB malicioso capaz de emular pulsaciones de teclado. Mediante esta inyección de entrada, se lanza de forma automatizada una instancia de PowerShell que permite iniciar la cadena de ejecución maliciosa.
    \end{description}
\end{leftbar}

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Execution (TA0002).
        \item[Técnica:] Command and Scripting Interpreter: PowerShell (T1059.001).
        \item[Procedimiento:] La carga inicial ejecuta comandos PowerShell para conectarse a la infraestructura del atacante, descargar un archivo malicioso y ejecutarlo en el sistema comprometido.
    \end{description}
\end{leftbar}

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Command and Control (TA0011).
        \item[Técnica:] Ingress Tool Transfer (T1105).
        \item[Procedimiento:] A través de la conexión establecida, el atacante transfiere un ejecutable adicional desde su servidor de mando y control, el cual actuará como componente de acceso remoto o reverse shell.
    \end{description}
\end{leftbar}

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Execution (TA0002).
        \item[Técnica:] User Execution: Malicious File (T1204.002).
        \item[Procedimiento:] El archivo malicioso descargado es ejecutado en el host, activando la carga útil diseñada para proporcionar al atacante acceso remoto.
    \end{description}
\end{leftbar}

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Command and Control (TA0011).
        \item[Técnica:] Remote Access Software (T1219).
        \item[Procedimiento:] El ejecutable estable una comunicación activa con el servidor C2, ofreciendo al atacante una shell interactiva mediante software de acceso remoto legítimo utilizado de forma maliciosa.
    \end{description}
\end{leftbar}

\subsection{Instalación}

\textit{Consultar la actividad del Red Team en la Sección~\ref{sec:red-team-instalacion} y el análisis del Blue Team en la Sección~\ref{sec:blue-team-instalacion}.}

\subsubsection{Stage 2}

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Discovery (TA0007).
        \item[Técnica:] File and Directory Discovery (T1083).
        \item[Procedimiento:] El adversario examina directorios de aplicación en busca de DLLs cargadas mediante rutas relativas, identificando candidatos apropiados para manipular el orden de búsqueda de DLLs.
    \end{description}
\end{leftbar}

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Defense Evasion / Privilege Escalation (TA0005 / TA0004).
        \item[Técnica:] Hijack Execution Flow: DLL Search Order Hijacking (T1574.001).
        \item[Procedimiento:] Una vez identificado un binario vulnerable, el atacante inserta una DLL maliciosa con el mismo nombre que la DLL legítima esperada por la aplicación, logrando que sea cargada primero debido al orden de búsqueda de DLLs en Windows.
    \end{description}
\end{leftbar}

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Defense Evasion (TA0005).
        \item[Técnica:] Signed Binary Proxy Execution (T1218).
        \item[Procedimiento:] El binario legítimo se emplea como contenedor para ejecutar la DLL maliciosa, aprovechando su firma y reputación para evadir mecanismos de seguridad basados en confianza.
    \end{description}
\end{leftbar}

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Defense Evasion (TA0005).
        \item[Técnica:] Reflective Code Loading (T1620).
        \item[Procedimiento:] La DLL maliciosa ejecuta el implante de Sliver directamente desde memoria mediante carga reflexiva, evitando la escritura en disco y reduciendo exponencialmente la superficie de detección.
    \end{description}
\end{leftbar}

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Execution (TA0002).
        \item[Técnica:] Ingress Tool Transfer (T1105).
        \item[Procedimiento:] El implante de Sliver o componentes adicionales son transferidos desde la infraestructura del adversario hacia la máquina víctima para completar el proceso de compromiso.
    \end{description}
\end{leftbar}

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Command and Control (TA0011).
        \item[Técnica:] Application Layer Protocol (T1071).
        \item[Procedimiento:] El implante establece un canal de comunicación cifrado con el servidor C2 del atacante para continuar con acciones post-compromiso.
    \end{description}
\end{leftbar}


\subsection{Mando y Control (C2)}

\textit{Consultar la actividad del Red Team en la Sección~\ref{sec:red-team-c2} y el análisis del Blue Team en la Sección~\ref{sec:blue-team-c2}.}

\begin{leftbar}
    \begin{description}
        \item[Táctica:] Command and Control (TA0011).
        \item[Técnicas:]
            \begin{itemize}
                \item Application Layer Protocol: Web Protocols (T1071.001).
                \item Encrypted Channel (T1573).
            \end{itemize}
        \item[Procedimiento:] El implante final establece un canal de comunicación (\textit{beaconing}) con el servidor C2. Esta comunicación se tuneliza sobre HTTPS (T1071.001) y utiliza un canal de cifrado (T1573) para ocultar las órdenes y la exfiltración de datos, mimetizando el tráfico web legítimo.
    \end{description}
\end{leftbar}

\subsection{Acciones sobre Objetivos}

\textit{Consultar la actividad del Red Team en la Sección~\ref{sec:red-team-acciones} y el análisis del Blue Team en la Sección~\ref{sec:blue-team-acciones}.}

 
\chapter{Red Team Notes}

En esta sección se presentan todos los detalles relacionados con el desarrollo técnico del ataque, incluyendo la justificación de las decisiones adoptadas y las referencias a los repositorios necesarios para comprender y reproducir las técnicas empleadas.

\section{Vectores de Acceso Inicial en Ejercicios Red Team: Justificación del Uso de BadUSB}

El vector de \textit{Initial Access} seleccionado para este proyecto se basa en el uso de un dispositivo \textit{BadUSB}. Aunque no se trata de un método habitual en operaciones reales —debido a la necesidad de acceso físico, la existencia de controles como el bloqueo de puertos USB o la restricción de combinaciones como \texttt{Win + R}— su utilización resulta especialmente adecuada en un contexto didáctico.

La elección de BadUSB responde a su capacidad para ofrecer un escenario de ataque claro, reproducible y fácilmente comprensible. Permite demostrar de forma directa cómo una simple emulación de teclado puede derivar en la ejecución de código arbitrario en un sistema protegido, mostrando así el impacto que puede tener un fallo en los controles físicos o en las políticas de endurecimiento del puesto de trabajo.

Desde una perspectiva de ciberseguridad, este vector no difiere conceptualmente de otros métodos de acceso inicial ampliamente empleados por actores maliciosos. Tanto la explotación de vulnerabilidades (que suele culminar en la ejecución de un \textit{payload} en memoria) como las campañas de \textit{phishing} que despliegan instaladores maliciosos (\texttt{.msi}, \texttt{.exe}) o capturan credenciales válidas, comparten la misma finalidad: obtener la primera ejecución de código en el sistema de la víctima.

Para este ejercicio se empleó un payload BadUSB de desarrollo propio, adaptado al escenario del laboratorio \cite{badusb-payload}.

\subsection{Bypass de AMSI}

Cuando el acceso inicial se realiza mediante un dispositivo BadUSB, la ejecución del código suele producirse a través de PowerShell. Esto implica que el primer mecanismo defensivo que debe evadirse habitualmente es AMSI (Antimalware Scan Interface), ya que intercepta y analiza el contenido antes de que PowerShell lo interprete.

Uno de los bypasses más utilizados es la técnica conocida como \textit{AMSI Bypass – Memory Patching}. Durante la ejecución de código, PowerShell —o cualquier motor de scripting— invoca la función \texttt{AmsiScanBuffer()} presente en \texttt{amsi.dll}. Mediante la modificación en tiempo de ejecución de los bytes asociados al valor de retorno de esta función, es posible forzar que devuelva siempre un resultado “limpio” (por ejemplo, \texttt{0x80070057}, correspondiente a \texttt{E\_INVALIDARG}). En muchas versiones de Windows, AMSI interpreta este estado como un fallo no malicioso y permite la ejecución del contenido sin aplicar medidas de bloqueo. \textit{AMSI Bypass – Memory Patching: \cite{amsi-bypass-patching}}

En determinados escenarios, AMSI puede detectar intentos de manipulación directa de \texttt{AmsiScanBuffer()} y finalizar el proceso de manera inmediata, lo que limita la eficacia del método anterior. Para abordar esta situación se emplea una técnica alternativa ampliamente documentada.

El segundo método utilizado fue el \textit{AMSI Bypass – Memory Patching via Reflection}. Durante la inicialización de PowerShell, la clase privada \\ \texttt{System.Management.Automation.AmsiUtils} crea una variable estática denominada \texttt{amsiInitFailed}. Si este valor se establece en \texttt{true}, AMSI considera que su inicialización ha fallado y desactiva de forma global todos los análisis para el resto de la sesión, independientemente de que \texttt{amsi.dll} continúe cargada y operativa. Este enfoque resulta especialmente útil en entornos donde el parcheo directo del buffer es detectado y bloqueado. \textit{AMSI Bypass - Memory Patching via Reflection: \cite{amsi-bypass-reflection}}


\section{Programar shellcodes}

Un shellcode es una secuencia de instrucciones ensambladas en formato position-independent, capaz de ejecutarse en cualquier ubicación de memoria sin asumir un punto de entrada fijo. Esto permite que, independientemente de dónde sea cargado el bloque de código, su ejecución produzca un comportamiento controlado y determinista, característica esencial en escenarios de explotación y ejecución arbitraria.

\subsection{Position-Independent Code (PIC)}

Una característica fundamental del \textit{shellcode} es que debe estar implementado como \textit{Position-Independent Code} (PIC). Esto implica que el código puede ejecutarse desde cualquier dirección de memoria sin asumir un \textit{entry point} fijo. A diferencia de los programas compilados tradicionalmente —por ejemplo, un binario en C— que comienzan su ejecución en una dirección conocida y pueden referenciar offsets internos predecibles, un \textit{shellcode} se ejecuta desde ubicaciones arbitrarias, desconocidas para sí mismo.

Para funcionar correctamente en este entorno dinámico, el \textit{shellcode} debe ser capaz de determinar en tiempo de ejecución su posición en memoria. En arquitecturas como x86, una técnica clásica para lograrlo es el patrón \texttt{call-pop}, que permite recuperar el valor del contador de programa (\texttt{EIP}):

\begin{verbatim}
_start:
    call geteip

geteip:
    pop edx
    lea edx, [edx - 5]
\end{verbatim}

La instrucción \texttt{call} empuja en la pila la dirección de retorno, que corresponde a la siguiente instrucción ejecutable. Al hacer un \texttt{pop} sobre ese valor, el \textit{shellcode} recupera la dirección efectiva donde se encuentra en memoria. Restando el tamaño de la instrucción previa, se obtiene así el punto de inicio del propio bloque de código.  

Esta técnica permite que el \textit{shellcode} utilice rutas relativas para acceder a datos incrustados, cadenas, estructuras o código adicional, manteniendo su independencia respecto a la dirección donde haya sido inyectado.


\subsection{Runtime Linking}

Una vez resuelto el problema del \textit{Position Independent Code} (PIC), el siguiente desafío fundamental en el desarrollo de shellcode es cómo invocar código de librerías dinámicas del sistema operativo. Cualquier operación relevante en Windows —como gestionar archivos, crear procesos o interactuar con memoria— requiere acceder a las \textit{system calls} expuestas a través de módulos como \texttt{kernel32.dll}. Sin embargo, en un shellcode no disponemos del trabajo que normalmente realizan el \textit{linker} en tiempo de compilación y el \textit{loader} en tiempo de carga, por lo que debemos reproducir este proceso manualmente durante la ejecución.

El objetivo principal consiste en localizar módulos cargados en el proceso y resolver las direcciones de sus funciones exportadas en tiempo de ejecución. Para ello recurrimos al \textit{Process Environment Block} (PEB), cuya dirección es mantenida por la CPU en registros dedicados (\texttt{FS:[0x30]} en x86 y \texttt{GS:[0x60]} en x64). Desde el PEB es posible iterar sus estructuras internas, en particular la lista doblemente enlazada \textit{InMemoryOrderModuleList}, que contiene información sobre todos los módulos cargados, incluyendo sus \textit{base addresses}.

Una vez obtenida la base de un módulo concreto, el siguiente paso es analizar sus encabezados PE hasta localizar la \textit{Export Table}. Esta tabla contiene los nombres de las funciones exportadas, sus \textit{ordinals} y, lo más importante, los \textit{Relative Virtual Addresses} (RVAs) que permiten calcular la dirección real de cada función mediante:

\[
\text{func\_addr} = \text{module\_base} + \text{RVA}
\]

Iterando esta tabla hasta encontrar la función deseada, el shellcode puede reconstruir la dirección exacta y, a partir de ese momento, invocar la API igual que lo haría un binario convencional.

Este mecanismo resuelve completamente la problemática del \textit{runtime linking} dentro de un entorno sin información previa como es el shellcode. Para este proyecto se han utilizado implementaciones propias en ensamblador tanto para la obtención del \textit{module base address} a través del PEB, como para la resolución dinámica de funciones exportadas. Dichas implementaciones pueden consultarse en los siguientes repositorios:

\begin{itemize}
    \item Implementación de \texttt{GetModuleHandle}-like:
    \begin{itemize}
        \item x64: \cite{x64_get_module}
        \item x86: \cite{x86_get_module}
    \end{itemize}
    \item Implementación de \texttt{GetProcAddress}-like:
    \begin{itemize}
        \item x64: \cite{x64_get_proc}
        \item x86: \cite{x86_get_proc}
    \end{itemize}
\end{itemize}

\subsubsection{Hashing de nombres de funciones}

Como medida de evasión y anti-análisis, es conveniente evitar incluir cadenas de texto en claro dentro del shellcode. Si los nombres de las funciones o módulos aparecen directamente en el binario, un analista puede identificarlos de manera inmediata aplicando herramientas básicas de extracción de cadenas. Para mitigar esto, una técnica habitual consiste en emplear algoritmos de \textit{hashing} para representar los nombres de las funciones que queremos resolver en tiempo de ejecución.

En este proyecto se ha implementado un sistema de hashing sencillo basado en rotaciones y operaciones XOR. Con este mecanismo, el shellcode almacena únicamente los valores hash, lo que dificulta la identificación directa de las APIs utilizadas. Durante la ejecución, las funciones exportadas del módulo correspondiente se recorren una a una, calculando su hash y comparándolo con el valor objetivo.

Las implementaciones en ensamblador utilizadas son las siguientes:

\begin{itemize}
    \item Hashing x64: \cite{x64_hash}
    \item Hashing x86: \cite{x86_hash}
\end{itemize}

\subsection{ABI en x86 y x64}

Finalmente, al trabajar con shellcode es imprescindible respetar las reglas de la \textit{Application Binary Interface} (ABI), especialmente en entornos x64. En esta arquitectura, la pila debe mantenerse alineada a 16 bytes en el momento de realizar una llamada a una función (\texttt{RSP mod 16 = 0}). Además, la convención de llamadas de Windows x64 exige reservar un \textit{shadow space} de 32 bytes antes de invocar cualquier función de una DLL del sistema; si estas condiciones no se cumplen, las llamadas pueden fallar de forma silenciosa o provocar un comportamiento indefinido.

También es necesario considerar la convención de llamadas utilizada para interactuar con las APIs del sistema. En x86, los argumentos se pasan por pila siguiendo un orden \textit{right-to-left}. En x64, los primeros cuatro parámetros se pasan mediante registros (\texttt{RCX}, \texttt{RDX}, \texttt{R8} y \texttt{R9}), mientras que el resto se colocan en la pila respetando la alineación mencionada. Asimismo, la gestión de \textit{stack frames}, la preservación de registros no volátiles y otras tareas que habitualmente realiza el compilador deben ser manejadas explícitamente dentro del shellcode.

Cumplir estrictamente estas normas resulta esencial para garantizar que las funciones del sistema operativo se ejecuten correctamente y que el shellcode mantenga un comportamiento estable y predecible.

\subsection{Payloads finales}

Una vez establecidos los tres pilares fundamentales para el desarrollo de shellcode —\textit{Position Independent Code} (PIC), \textit{runtime linking} y respeto de la ABI— es posible construir payloads completamente personalizados desde cero.

Como recomendación práctica, resulta útil desarrollar primero el programa equivalente en C y compilarlo sin optimizaciones. Esto permite tener una referencia clara de cómo debería verse el comportamiento final y observar directamente cómo el compilador gestiona aspectos como las llamadas a funciones, las variables locales o el uso del stack.

De forma adicional, en algunas circunstancias puede ser útil cargar un binario compilado en C en una herramienta de análisis estático como IDA, para comprobar el tamaño que el compilador reserva para ciertas variables o estructuras. Esto es especialmente práctico cuando ciertos valores no son triviales de deducir únicamente a partir de la documentación.

A continuación se muestran ejemplos de payloads desarrollados para este proyecto:

\paragraph{MessageBox payload}  
Un payload sencillo cuyo objetivo es mostrar un \textit{message box}. Se ha utilizado para validar las rutinas de inyección de código y comprobar la correcta resolución de funciones mediante \textit{runtime linking}.

\begin{itemize}
    \item x64: \cite{github-messagebox-x64}
    \item x86: \cite{github-messagebox-x86}
\end{itemize}

\paragraph{Reverse Shell payload}
Este es el \textbf{payload utilizado en la versión final del ataque} descrito en este trabajo. Se trata de la reverse shell empleada durante toda la ejecución práctica del ejercicio Red Team.

Por motivos didácticos, el shellcode de la reverse shell se ha incluido dentro de un fichero PE mínimo para que quede rastro en disco y su análisis resulte más sencillo posteriormente.
Para generar este PE se ha utilizado la herramienta \texttt{sclauncher} \cite{sclauncher}, que crea únicamente las cabeceras básicas del ejecutable, define una sección \texttt{.text} y coloca en ella el bloque de shellcode. De este modo, el loader de Windows lo mapea correctamente y transfiere la ejecución a la shellcode sin necesidad de estructuras adicionales.

\begin{itemize}
\item \textbf{Reverse shell x86 (payload final utilizado en el ataque):} \cite{github-reverseshell-x86}
\end{itemize}

\section{Inyección de código}

La inyección de código consiste en conseguir que un proceso ejecute instrucciones distintas a las previstas originalmente. Existen múltiples técnicas para lograrlo, pero todas se basan en un principio común: modificar el flujo de ejecución o incorporar código arbitrario dentro del espacio de memoria de un proceso legítimo.

Los métodos clásicos incluyen la reserva de memoria en el proceso objetivo para copiar y ejecutar shellcode, así como la carga forzada de librerías que el binario no tenía previstas. Esta última categoría da lugar a un conjunto amplio de técnicas orientadas a manipular la forma en que Windows resuelve y carga DLLs.

Dentro de estas técnicas, una de las más relevantes y estudiadas es el DLL Hijacking. 

\subsection{DLL Hijacking}

El \textit{DLL Hijacking} consiste en forzar que el \textit{loader} de Windows cargue una biblioteca dinámica controlada por el atacante, aprovechando el orden de búsqueda de DLLs o configuraciones del sistema.

\paragraph{Objetivo principal}  
Lograr que un ejecutable legítimo cargue una DLL maliciosa con el mismo nombre que una DLL esperada, pero ubicada en una ruta que el atacante controla.

\subsubsection{Orden de carga de DLLs en Windows}

El \textit{loader} resuelve las dependencias siguiendo el siguiente orden:

\begin{enumerate}
    \item Directorio desde el cual se cargó la aplicación.
    \item \texttt{C:\textbackslash Windows\textbackslash System32}
    \item \texttt{C:\textbackslash Windows\textbackslash System}
    \item \texttt{C:\textbackslash Windows}
    \item Directorio de trabajo actual (CWD).
    \item Directorios definidos en la variable de entorno \texttt{PATH} del sistema.
    \item Directorios definidos en la variable de entorno \texttt{PATH} del usuario.
\end{enumerate}

\subsubsection{KnownDLLs — Restricción crítica}

Las DLL listadas en:

\begin{verbatim}
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs
\end{verbatim}

solo pueden cargarse desde \texttt{System32}, lo que imposibilita su secuestro mediante \textit{DLL Hijacking} tradicional.

\subsection{Weaponización de DLL Hijacking}

Para convertir este mecanismo en una técnica ofensiva se emplean tres enfoques complementarios: \textit{Side Loading}, \textit{DLL Proxying} y \textit{Reflective Loading}.

para el ataque concreto este trabajo se exploto la aplicacion legitima calibre y se su dll (https://hijacklibs.net/entries/3rd_party/calibre/calibre-launcher.html)

% -----------------------------------------------------------
\subsubsection{Side Loading}

El \textit{Side Loading} consiste en colocar una DLL maliciosa en el mismo directorio que el ejecutable objetivo, confiando en que el orden de carga priorizará ese directorio.  
Una limitación habitual es la falta de permisos de escritura en las rutas donde residen los binarios legítimos. Sin embargo, estas rutas sí permiten lectura, por lo que es posible copiar el ejecutable legítimo a un directorio controlado por el atacante, donde sí se pueden introducir DLLs maliciosas.

Para explotar correctamente esta técnica, la DLL maliciosa debe utilizar exactamente el mismo nombre que la DLL legítima requerida por el programa.

por ejemplo podemos mover los archivos de la ruta legitima a una ruta que no sea muy sospechosa

robocopy "C:\Program Files\Calibre2" "C:\Users\test\Documents\zz" /E /COPY:DAT /R:3 /W:5

% -----------------------------------------------------------
\subsubsection{DLL Proxying}

Sustituir una DLL legítima por una maliciosa puede causar fallos, ya que el programa depende de las funciones exportadas por la DLL original.  
Para evitarlo, se utiliza \textit{DLL Proxying}. Esta técnica consiste en compilar una DLL maliciosa que:

\begin{itemize}
    \item Inyecta el comportamiento deseado (payload).
    \item Replica todas las exportaciones de la DLL legítima.
    \item Redirige cada exportación a la DLL original renombrada.
\end{itemize}

El resultado es un comportamiento equivalente a un \textit{man-in-the-middle} dentro del propio mecanismo de carga de DLLs.

% -----------------------------------------------------------
\subsubsection{Reflective Loading}

Una limitación inherente al diseño de Windows es que las DLL solo pueden cargarse desde disco mediante las API estándar.  
La técnica de \textit{Reflective Loading} elude esta restricción cargando la DLL directamente desde memoria, sin necesidad de que exista en disco. Esto permite evadir firmas estáticas y gran parte de las detecciones basadas en \textit{file scanning}.


\section{Persistenca}

claves de registro

servicios

tareas programas

strat menu

dll hijacking de un ejecutable que cargue el sistema


\section{Infraestructura C2}

> fata toda la parte de AWS

% 
% 
% 
\chapter{Blue Team}

\section{Recopilacion de evidencias}

kepe + memoria

la idea seria hacer la pate inversa a la seccion del red team, ahora todo lo que se ha desarrollado buscarlo y demostrarlo con artefactos