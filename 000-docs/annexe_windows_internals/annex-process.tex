\section{Process}

\begin{itemize}
    \item \textbf{EPROCESS:} Estructura que mantiene toda la información de un proceso en el kernel.
    \item \textbf{Threads:} Representan las hebras de ejecución asociadas al proceso.
    \item \textbf{Handles:} Son equivalentes a los \textit{file descriptors} en Linux.
    \item \textbf{Memory:} Gestión del espacio de direcciones y memoria asignada al proceso.
    \item \textbf{Modules:} Lista de módulos y librerías cargadas en el proceso.
\end{itemize}

\subsection{Process Creation (Kernel)}

La creación de un proceso en Windows sigue una serie de pasos específicos a nivel
del kernel.

\subsubsection*{(1) Inicialización del espacio de direcciones}

\begin{itemize}[leftmargin=1.5cm]
    \item \textbf{Modelo en Linux vs. Windows:} En Linux, los nuevos procesos se crean
    mediante la llamada \texttt{fork}, mientras que en Windows los procesos se inicializan
    completamente desde cero.
    \item \textbf{Mapeo de \texttt{KUSER\_SHARED\_DATA}:} Al crear un nuevo proceso, el
    kernel debe mapear memoria. Una de las primeras acciones es mapear la página de 4KB
    denominada \texttt{KUSER\_SHARED\_DATA}, la cual permite intercambiar información entre
    \textit{user mode} y \textit{kernel mode} sin necesidad de \textit{syscalls}. En esta
    página se encuentran datos como el reloj del sistema y las rutas a directorios del
    sistema.
    \item \textbf{Mapeo del ejecutable:} Posteriormente, el kernel carga el ejecutable
    dentro del proceso. Concretamente, carga el código PE en la sección \texttt{.text}.
    \item \textbf{Mapeo de \texttt{ntdll.dll}:} El kernel carga el módulo \texttt{ntdll.dll},
    el cual actúa como intermediario entre el \textit{user-mode} y el kernel. Este módulo
    contiene las funciones necesarias para la comunicación con el kernel y cumple un rol
    similar al \texttt{ld.so} en Linux.
    \item \textbf{Asignación del PEB (Process Environment Block):} El \texttt{PEB} es una
    estructura de datos en \textit{user mode} (aproximadamente 1--2 páginas de memoria) que
    contiene:
    \begin{itemize}
        \item Variables de entorno.
        \item Línea de comandos completa con la que se inició el proceso.
        \item Directorio de trabajo.
        \item Lista de módulos cargados (\texttt{Ldr}).
        \item Punteros al \texttt{stack} y \texttt{heap}.
        \item Dirección base de la imagen.
    \end{itemize}
\end{itemize}

\subsubsection*{(2) Creación del hilo inicial}

\begin{itemize}[leftmargin=1.5cm]
    \item \textbf{Mapeo del stack:} Se asigna el espacio de pila necesario para el hilo
    principal.
    \item \textbf{Mapeo del TEB (Thread Environment Block):} El \texttt{TEB} es una
    estructura pequeña (2 páginas aprox.) que almacena información específica de cada hilo.
    Su función es equivalente al \texttt{PEB}, pero a nivel de hilo.
    \item \textbf{Inicialización del puntero de ejecución:} Finalmente, el puntero de
    ejecución se coloca en la función \texttt{ntdll.LdrInitializeThunk}, encargada de
    completar la carga dinámica del proceso.
\end{itemize}


\section{PEB y la lista de módulos}
El \textbf{Process Environment Block (PEB)} es una estructura interna de Windows 
que contiene información sobre el proceso, incluyendo los módulos (DLLs) 
cargados. 

Dentro del PEB, el campo:
\begin{verbatim}
PEB->Ldr->InMemoryOrderModuleList
\end{verbatim}
es una lista enlazada que mantiene todos los módulos cargados en memoria, 
incluyendo la DLL principal del proceso y todas las DLLs dependientes. Cada 
entrada de esta lista contiene:

\begin{itemize}
    \item La \texttt{base address} del módulo en memoria.
    \item El nombre del archivo de la DLL.
    \item Información sobre sus secciones.
\end{itemize}

Recorrer esta lista permite obtener todas las DLLs cargadas y sus direcciones en 
memoria.


\section{Secciones de un proceso}

El espacio de direcciones de un proceso en memoria se organiza en diferentes secciones.
A continuación, se enumeran las mismas desde las direcciones más altas hasta las más bajas:

\begin{description}[style=nextline, leftmargin=2cm]

    \item[\textbf{Páginas del Kernel}]  
    Ocupan la misma dirección en todos los procesos del sistema y corresponden al kernel.  
    Como todas las páginas de kernel apuntan a los mismos \textit{frames} de memoria física, 
    no se desperdicia espacio cargando el kernel en cada proceso.  
    El acceso se realiza únicamente mediante llamadas al sistema.

    \item[\textbf{Stack (lectura y escritura)}]  
    Estructura de almacenamiento \textit{LIFO}, que crece hacia abajo 
    (desde el final del espacio de direcciones del proceso hacia la sección BSS).  
    Cada función tiene su propio \textit{stack frame}, con variables locales y argumentos.  
    El tamaño suele estar limitado entre 1 y 8 MB, según la arquitectura y el sistema operativo.  
    Su gestión mediante el puntero de pila es muy rápida.

    \item[\textbf{Heap (lectura y escritura)}]  
    Espacio para memoria dinámica gestionada por llamadas como \texttt{malloc}.  
    Crece hacia arriba, desde el final de la BSS hasta el final del espacio de direcciones.  
    Su administración mediante el puntero de \textit{heap} es más lenta que la del \textit{stack}.

    \item[\textbf{BSS y Data (lectura y escritura)}]  
    Almacenan las variables globales y estáticas del programa.  
    La sección \textbf{BSS} contiene las variables no inicializadas,  
    mientras que la sección \textbf{Data} guarda las variables inicializadas.

    \item[\textbf{Text (lectura y ejecución)}]  
    Contiene el código ejecutable del programa, cargado desde el binario en disco.  
    Generalmente está marcada como de solo lectura y ejecución.

\end{description}
